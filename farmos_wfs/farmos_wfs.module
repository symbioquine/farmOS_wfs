<?php

/**
 * @file
 * WFS module.
 */

define("FARMOS_WFS_IMPLEMENTATION_VERSION", '1.1.0');
define("FARMOS_WFS_DEFAULT_CRS", 'EPSG:4326');

/**
 * Implements hook_menu().
 */
function farmos_wfs_menu() {
  $items = array();
  $items['wfs'] = array(
    'title' => 'WFS Endpoint',
    'description' => 'Provides a WFS endpoint for farmOS',
    'file' => 'handle_wfs_request.inc',
    'page callback' => 'handle_wfs_request',
    'access arguments' => array('view farm areas'),
    'delivery callback' => 'farmos_wfs_deliver_results',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
* Implements hook_init().
*/

function farmos_wfs_init() {
  if (current_path() == 'wfs') {
    drupal_page_is_cacheable(FALSE);
  }
}

/**
 * Transform responses the final output.
 */
function farmos_wfs_deliver_results($page_callback_result) {

  if (is_int($page_callback_result) && $page_callback_result == MENU_ACCESS_DENIED) {

    drupal_add_http_header('Status', '403 Forbidden');

    $page_callback_result = farmos_wfs_makeExceptionReport(function($eReport, $elem) {
      $eReport->appendChild($elem('Exception', array(
        "exceptionCode"  => "AccessDenied",
      ), $elem('ExceptionText', [], "Access denied")));
    });

  }

  if ($page_callback_result instanceof DOMDocument) {
    drupal_add_http_header('Content-Type', 'application/xml; utf-8');
    print $page_callback_result->saveXML();
    return drupal_exit();
  }

  return drupal_deliver_html_page($page_callback_result);
}

function farmos_wfs_makeDoc($declarator) {
  $xml = new DomDocument('1.0', 'UTF-8');

  $elem = null;
  $elem = function($name, $attrs, $elemContent = null) use ($xml, &$elem) {
    $e = $xml->createElement($name);

    foreach ($attrs as $attrKey => $attrVal) {
      $e->setAttribute($attrKey, $attrVal);
    }

    if (isset($elemContent)) {
      if (is_callable($elemContent)) {
        $elemContent($e, $elem);
      } elseif ($elemContent instanceof DOMNode) {
        $e->appendChild($elemContent);
      } elseif (is_string($elemContent)) {
        $e->nodeValue = $elemContent;
      }
    }

    return $e;
  };

  $declarator($xml, $elem);

  $xml->formatOutput = TRUE;

  return $xml;
}

function farmos_wfs_makeExceptionReport($declarator) {
  return farmos_wfs_makeDoc(function($doc, $elem) use ($declarator) {
    $doc->appendChild($elem('ExceptionReport', array(
      'xmlns' => "http://www.opengis.net/ows/1.1",
      'xmlns:xsi' => "http://www.w3.org/2001/XMLSchema-instance",
      'xsi:schemaLocation' => "http://www.opengis.net/ows/1.1 owsExceptionReport.xsd",
      'version' => FARMOS_WFS_IMPLEMENTATION_VERSION,
      'xml:lang' => "en",
    ), $declarator));
  });
}


define("FARMOS_WFS_EMPTY_FILTER_BEHAVIOR_MATCH_ALL", 'match_all');
define("FARMOS_WFS_EMPTY_FILTER_BEHAVIOR_MATCH_NONE", 'match_none');

/*
 * Retrieves an array of taxonomy ids for the areas which have a particular geometry type and (optionally) match a OGC Filter or fall within a given bounding box.
 */
function farmos_wfs_ogc_filter_one_point_one_to_area_ids($geo_types, $filter_elem, $bbox = null, $empty_filter_behavior = FARMOS_WFS_EMPTY_FILTER_BEHAVIOR_MATCH_NONE) {

  $filter_ids = [];
  if ($filter_elem) {
    $distinct_child_names = array_unique(array_map(function($e) { return $e->localName; }, iterator_to_array($filter_elem->childNodes)));

    if (empty($distinct_child_names)) {
      throw new Exception("Illegal filter expression. Cannot be empty.");
    }

    if (count($distinct_child_names) > 1) {
      $distinct_child_names_str = print_r($distinct_child_names, TRUE);
      throw new Exception("Illegal filter expression. Heterogeneous children of types: $distinct_child_names_str");
    }

    if ($distinct_child_names[0] == 'FeatureId' || $distinct_child_names[0] == 'GmlObjectId') {

      $children_with_tag = 'farmos_wfs_get_xnode_children_with_tag';

      $filter_raw_ids = array_merge(
        array_map(function ($e) { return $e->getAttribute('fid'); }, $children_with_tag($filter_elem, 'FeatureId')),
        array_map(function ($e) { return $e->getAttribute('id'); }, $children_with_tag($filter_elem, 'GmlObjectId')),
      );

      $filter_ids = array_map(function($raw_id) {
        return preg_replace('/^[^.]+\.(\d+)$/', '$1', $raw_id);
      }, $filter_raw_ids);

    } else {
      throw new Exception("Unsupported filter operation: {$distinct_child_names[0]}");
    }

  }

  // Bail if the filter has no criteria - i.e. don't support vacuously matching all features
  // TODO: Also check other filter criteria once those are supported
  if ($empty_filter_behavior == FARMOS_WFS_EMPTY_FILTER_BEHAVIOR_MATCH_NONE &&
    empty($filter_ids) && empty($bbox)) {
      return [];
  }

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'farm_areas');

  if (!empty($geo_types)) {
    $query->fieldCondition('field_farm_geofield', 'geo_type', $geo_types, 'IN', 0);
  }

  // TODO: Consider handling features and/or bounding boxes which cross the anti-meridian
  if (!empty($bbox)) {
    $query->fieldCondition('field_farm_geofield', 'top', $bbox[0], '>=', 0);
    $query->fieldCondition('field_farm_geofield', 'right', $bbox[1], '>=', 0);
    $query->fieldCondition('field_farm_geofield', 'bottom', $bbox[2], '<=', 0);
    $query->fieldCondition('field_farm_geofield', 'left', $bbox[3], '<=', 0);
  }

  if (!empty($filter_ids)) {
    $query->propertyCondition('tid', $filter_ids, 'IN');
  }

  $result = $query->execute();

  if (isset($result['taxonomy_term'])) {
    return array_keys($result['taxonomy_term']);
  }

  return [];
}

function farmos_wfs_get_xnode_children_with_tag($node, $tag) {
  if (!$node) {
    return [];
  }
  return farmos_wfs_filter_xnodes_by_local_name(iterator_to_array($node->childNodes), $tag);
}

function farmos_wfs_filter_xnodes_by_local_name($nodes, $localName) {
  return array_values(array_filter($nodes, function($n) use ($localName) {
    return $n->localName == $localName;
  }));
}
